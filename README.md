# SimDoc DB

[Êó•Êú¨Ë™û](#Êó•Êú¨Ë™û)

SimDoc DB is a simple in-memory document database (NoSQL) written in TypeScript. Do you think it is reinventing the wheel? Yes, it is, to some extent. But great advantages of what this library has are:

-   It supports full text search for any multibyte characters by default.
    -   Including Japanese (Êó•Êú¨Ë™û) and emoji (üòÑ).
-   It doesn't have any dependencies of other libraries at all.
-   It works on both Node.js as well as web browsers.
-   It is super lightweight thus super quick.
    -   19KB JS files in total (as of version 0.12.0)

So if you're looking for a simple in-memory DB solution for SPA running on web browsers, it can be a perfect solution.

On the other hand, it doesn't support storing and indexing JSON directly. Meaning, it can't handle multi-layered data structure. Also it doesn't support range search such as "less-than" or "greater-than". This is a tradeoff of keeping this library super lightweight and quick.

## How to use

### Install the library

You can add this library to your TypeScript / JavaScript project by following command.

```
$ npm install @otchy/sim-doc-db
```

### Create collection

Once you have the dependency, you can start writing code. What you need to do first is to create a `Collection`.

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Field } from '@otchy/sim-doc-db/dist/types';

const SCHEMA: Field[] = [
    {
        name: 'key',
        type: 'tag',
        indexed: true,
    },
    {
        name: 'content',
        type: 'string',
        indexed: true,
    },
    {
        name: 'updatedAt',
        type: 'number',
        indexed: false,
    },
];

const collection = new Collection(SCHEMA);
```

As you can see above, you need to define the schema when you instantiate the `Collection` which is an array of `Field` objects. This schema represents the fields of each document stored in this collection.

Each field has its `type` which is defined as follows.

```ts
export type FieldType = 'string' | 'number' | 'boolean' | 'tag' | 'string[]' | 'number[]' | 'tags';
```

| type     | note                                      |
| -------- | ----------------------------------------- |
| string   | text field supporting full text search    |
| number   | number field supporting only exact match  |
| boolean  | boolean field supporting only exact match |
| tag      | text field supporting only exact match    |
| string[] | array of string type                      |
| number[] | array of number type                      |
| tags     | array of tag type                         |

Each field will be query-able when you set the `indexed` field as `true`. So with this example `SCHEMA`, you can query "key" field by exact match and "content" field by full text search, but you can't query "updatedAt" field.

### Add document

Now that you can start adding your documents to the `collection`. The document you add should follow the schema. But note that the data you want to store has to be defined as "values".

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const doc1: Document = collection.add({
    values: {
        key: 'doc_key_1',
        content: 'Any text üíØ‚ùóÔ∏è',
        updatedAt: Date.now(),
    },
});
const doc2: Document = collection.add({
    values: {
        key: 'doc_key_2',
        content: 'Text content üíØ‚ùóÔ∏è',
        updatedAt: Date.now(),
    },
});
/*
doc1 = {
    id: 1,
    values: ...,
};
doc2 = {
    id: 2,
    values: ...,
};
*/
```

You may notice that each document has an `id` field issued by the library automatically. This `id` is the identifier of each document. So you can `get` the document or `remove` the document with this `id`.

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const doc1: Document = collection.get(1);
const removedDoc1: Document = collection.remove(1);
```

### Query documents

Okay, finally you can query the documents as follows!

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const result1: Set<Document> = collection.find({ key: 'doc_key_1' });
const result2: Set<Document> = collection.find({ content: 'üíØ' });
```

The Set object `result1` has a document where its key exactly matches with "doc_key_1". The set object `result2` has 2 documents where those contents partially match with "üíØ".

If you want to sort the result, of course you can do it.

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const result: Document[] = Array.from(collection.find({ content: 'üíØ' }));
const sortedResult: Document[] = result.sort((left, right) => left.updatedAt - right.updatedAt);
```

Note that the type of query result is `Set`, so you need to convert it to `Array` if you need to sort it.

### Update document

When you want to update a document stored in the collection, you first need to know its `id`. Then you can call the `update` method to do so.

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const current: Document = Array.from(collection.find({ key: 'doc_key_1' }))[0];
const updated: Document = {
    id: current.id,
    values: {
        ...current.values,
        content: 'Updated!',
        updatedAt: Date.now(),
    },
};
collection.update(updated);
```

### Export and import

SimDoc DB itself doesn't have persistence because it is designed as a simple in-memory database. But it supports `export` and `import`, so you can use it if you want to save the database persistently.

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Json } from '@otchy/sim-doc-db/dist/types';

const jsonData: Json = collection.export();
const textData = Json.stringify(jsonData);
// save it somewhere

const copiedCollection = new Collection(SCHEMA);
copiedCollection.import(jsonData);
```

The format of the dumped data is `Json`. So you can `stringify` it to save the data on disk for example. You then of cource can `import` the data as needed.

### Multi-layerd data

As this document describes earlier, this library doesn't handle multi-layered data structure by design. But if you really need such kind of data structure, you can emulate it as follows.

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Field } from '@otchy/sim-doc-db/dist/types';

const SCHEMA: Field[] = [
    {
        name: 'groupId',
        type: 'number',
        indexed: true,
    },
    {
        name: 'name',
        type: 'string',
        indexed: true,
    },
    {
        name: 'members',
        type: 'string[]',
        indexed: false,
    },
];

type Member = {
    memberId: number;
    name: string;
};

type Group = {
    groupId: number;
    name: string;
    members: Member[];
};

const collection = new Collection(SCHEMA);

const addGroup = ({ groupId, name, members }: Group) => {
    collection.add({
        values: {
            groupId,
            name,
            members: members.map((member: Member) => JSON.stringify(member)),
        },
    });
};

const getGroup = (groupId: number): Group => {
    const doc = Array.from(collection.find({ groupId }))[0];
    return {
        groupId: doc.values.groupId,
        name: doc.values.name,
        members: doc.values.members.map((member) => JSON.parse(member) as Member),
    };
};
```

The downside of this pattern is that you can't query it by the member's name. It is possible to do `` collection.find({ members: `"name":"${name}"` }) `` to search JSON string. But that is pretty hacky and is not recommended.

Alternatively, you can do the following as well.

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Field } from '@otchy/sim-doc-db/dist/types';

const GROUP_SCHEMA: Field[] = [
    {
        name: 'groupId',
        type: 'number',
        indexed: true,
    },
    {
        name: 'name',
        type: 'string',
        indexed: true,
    },
    {
        name: 'memberIds',
        type: 'number[]',
        indexed: true,
    },
];

const MEMBER_SCHEMA: Field[] = [
    {
        name: 'memberId',
        type: 'number',
        indexed: true,
    },
    {
        name: 'groupId',
        type: 'number',
        indexed: false,
    },
    {
        name: 'name',
        type: 'string',
        indexed: true,
    },
];

type Member = {
    memberId: number;
    groupId: number;
    name: string;
};

type Group = {
    groupId: number;
    members: Member[];
};

const groupCollection = new Collection(GROUP_SCHEMA);
const memberCollection = new Collection(MEMBER_SCHEMA);

const addGroup = ({ groupId, name, members }: Group) => {
    groupCollection.add({
        values: {
            groupId,
            name,
            memberIds: members.map((member) => member.memberId),
        },
    });
    members.forEach(({ memberId, name }) => {
        memberCollection.add({
            values: {
                memberId,
                groupId,
                name,
            },
        });
    });
};

const getGroup = (groupId: number): Group => {
    const groupDoc = Array.from(groupCollection.find({ groupId }))[0];
    const members = groupDoc.values.memberIds.map((memberId) => {
        return Array.from(memberCollection.find({ memberId }))[0].values as Member;
    });
    return {
        groupId: groupDoc.values.groupId,
        name: groupDoc.values.name,
        members,
    };
};

const findByMemberName = (name: string): Group => {
    const memberDoc = Array.from(memberCollection.find({ name }))[0];
    const groupId = memberDoc.values.groupId;
    return getGroup(groupId);
};
```

This pattern is similar to how RDB handles multi-layered data. But you need to "JOIN" it by yourself since SimDoc DB doesn't support SQL.

### Range search

As this document describes earlier, this library doesn't support range search such as "less-than" or "greater-than" by design. You can't emulate it perfectly, but you can do similar search if you really need it.

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Field, Query } from '@otchy/sim-doc-db/dist/types';

const SCHEMA: Field[] = [
    {
        name: 'name',
        type: 'string',
        indexed: true,
    },
    {
        name: 'age',
        type: 'number',
        indexed: false,
    },
    {
        name: 'ageCategory',
        type: 'tags',
        indexed: true,
    },
    {
        name: 'isAdult',
        type: 'boolean',
        indexed: true,
    },
];

type Person = {
    name: string;
    age: number;
};

type AgeCategory = '<20' | '20-39' | '40-59' | '>=60';

const getAgeCategory = (age: number): AgeCategory => {
    if (age < 20) {
        return '<20';
    } else if (age < 40) {
        return '20-39';
    } else if (age < 60) {
        return '40-59';
    } else {
        return '>=60';
    }
};

const getIsAdult = (age: number): boolean => {
    return age >= 18;
};

const collection = new Collection(SCHEMA);

const addPerson = ({ name, age }: Person) => {
    const ageCategory = getAgeCategory(age);
    const isAdult = getIsAdult(age);
    collection.add({
        values: {
            name,
            age,
            ageCategory,
            isAdult,
        },
    });
};

const getPeople = (query: Query): Person[] => {
    return Array.from(collection.find(query)).map((doc) => {
        const { name, age } = doc.values;
        return { name, age } as Person;
    });
};

const getPeopleInAgeCategory = (ageCategory: AgeCategory): Person[] => {
    return getPeople({ ageCategory });
};
const getAdultPeople = () => {
    return getPeople({ isAdult: true });
};
```

This is not perfect solution, but can cover a lot of real use cases.

# Êó•Êú¨Ë™û

SimDoc DB „ÅØ TypeScript „ÅßÊõ∏„Åã„Çå„Åü„Ç∑„É≥„Éó„É´„Å™„Ç§„É≥„É°„É¢„É™„Éâ„Ç≠„É•„É°„É≥„Éà„Éá„Éº„Çø„Éô„Éº„Çπ (NoSQL) „Åß„Åô„ÄÇ„Å∂„Å£„Å°„ÇÉ„ÅëËªäËº™„ÅÆÂÜçÁô∫Êòé„Åß„ÅØ„ÅÇ„Çä„Åæ„Åô„Åå„ÄÅ„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„Å´„ÅØ‰ªñ„Åß„ÅØ„ÅÇ„Åæ„ÇäË¶ã„Å™„ÅÑ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å™Âà©ÁÇπ„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

-   „Éá„Éï„Ç©„É´„Éà„Åß„ÅÇ„Çâ„ÇÜ„ÇãÂ§ö„Éê„Ç§„ÉàÊñáÂ≠ó„ÅÆÂÖ®ÊñáÊ§úÁ¥¢„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
    -   Êó•Êú¨Ë™û„ÇÑÁµµÊñáÂ≠ó (üòÑ) „ÇÇÂïèÈ°å„Å™„Åó„ÄÇ
-   Â§ñÈÉ®„É©„Ç§„Éñ„É©„É™„Å´‰∏ÄÂàá‰æùÂ≠ò„Åõ„ÅöÂçò‰Ωì„ÅßÂãï‰Ωú„Åó„Åæ„Åô„ÄÇ
-   Node.js ‰∏ä„ÄÅ„Ç¶„Çß„Éñ„Éñ„É©„Ç¶„Ç∂‰∏ä„ÅÆ„ÅÑ„Åö„Çå„Åß„ÇÇÂãï‰Ωú„Åó„Åæ„Åô„ÄÇ
-   Ë∂ÖËªΩÈáè„ÅßË∂ÖÈ´òÈÄü„ÄÇ
    -   JS „Éï„Ç°„Ç§„É´„ÅÆÂêàË®à„Åß 19KB „Åß„Åô„ÄÇ(„Éê„Éº„Ç∏„Éß„É≥ 0.12.0 ÁèæÂú®)

„Å™„ÅÆ„Åß„ÄÅ„ÇÇ„Åó„Ç¶„Çß„Éñ„Éñ„É©„Ç¶„Ç∂‰∏ä„ÅßÂãï‰Ωú„Åô„Çã SPA „Åß‰Ωø„ÅÜ„Ç∑„É≥„Éó„É´„Å™„Ç§„É≥„É°„É¢„É™ DB „ÇíÊé¢„Åó„Å¶„ÅÑ„Çã„ÅÆ„Å™„Çâ„ÄÅ„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅåÂÆåÁíß„Å´„Éû„ÉÉ„ÉÅ„Åô„Çã„Åã„ÇÇ„Åó„Çå„Åæ„Åõ„Çì„ÄÇ

‰∏ÄÊñπ„Åß„ÄÅJSON „ÇíÁõ¥Êé•‰øùÂ≠ò„Åó„Åü„ÇäÊ§úÁ¥¢ÂØæË±°„Å´„Åó„Åü„Çä„Å®„ÅÑ„Å£„Åü„Åì„Å®„ÅØ„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Å§„Åæ„Çä„ÄÅÂ§öÈöéÂ±§„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„Çí„Åù„ÅÆ„Åæ„ÅæÊâ±„ÅÜ„Åì„Å®„ÅØÂá∫Êù•„Å™„ÅÑ„Å®„ÅÑ„ÅÜ‰∫ã„Åß„Åô„ÄÇ„Åæ„Åü„ÄÅ„Äå„Çà„ÇäÂ∞è„Åï„ÅÑ„Äç„Äå„Çà„ÇäÂ§ß„Åç„ÅÑ„Äç„ÅÆ„Çà„ÅÜ„Å™ÁØÑÂõ≤Ê§úÁ¥¢„ÇÇ„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åì„Çå„ÅØ„ÄÅ„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíË∂ÖËªΩÈáè„ÉªË∂ÖÈ´òÈÄü„Å´‰øù„Å§„Åü„ÇÅ„ÅÆ„Éà„É¨„Éº„Éâ„Ç™„Éï„Åß„Åô„ÄÇ

## ‰Ωø„ÅÑÊñπ

### „É©„Ç§„Éñ„É©„É™„ÅÆ„Ç§„É≥„Çπ„Éà„Éº„É´

TypeScript „ÅÇ„Çã„ÅÑ„ÅØ JavaScript „ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Å´‰ª•‰∏ã„ÅÆ„Ç≥„Éû„É≥„Éâ„Åß„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíËøΩÂä†„Åô„Çã„Åì„Å®„ÅåÂá∫Êù•„Åæ„Åô„ÄÇ

```
$ npm install @otchy/sim-doc-db
```

### „Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„ÅÆ‰ΩúÊàê

„ÅÑ„Å£„Åü„Çì„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÇíËøΩÂä†„Åó„Åü„Çâ„Ç≥„Éº„Éâ„ÇíÊõ∏„ÅçÂßã„ÇÅ„Çã„Åì„Å®„ÅåÂá∫Êù•„Åæ„Åô„ÄÇ„Åæ„Åö‰∏ÄÁï™ÊúÄÂàù„Å´„Åó„Å™„ÅÑ„Å®„ÅÑ„Åë„Å™„ÅÑ„ÅÆ„ÅØ„ÄÅ`Collection` „Çí‰ΩúÊàê„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Field } from '@otchy/sim-doc-db/dist/types';

const SCHEMA: Field[] = [
    {
        name: 'key',
        type: 'tag',
        indexed: true,
    },
    {
        name: 'content',
        type: 'string',
        indexed: true,
    },
    {
        name: 'updatedAt',
        type: 'number',
        indexed: false,
    },
];

const collection = new Collection(SCHEMA);
```

‰∏äË®ò„ÇíË¶ã„Çã„Å®ÂàÜ„Åã„Çã„Çà„ÅÜ„Å´„ÄÅ`Collection` „Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê„Åô„ÇãÊôÇ„ÅØ„ÄÅ`Field` „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÈÖçÂàó„Åã„Çâ„Å™„Çã„Çπ„Ç≠„Éº„Éû„ÇíÂÆöÁæ©„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åì„ÅÆ„Çπ„Ç≠„Éº„Éû„ÅØ„ÄÅ„Åì„ÅÆ„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„Å´‰øùÂ≠ò„Åï„Çå„Çã„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÂêÑ„Éï„Ç£„Éº„É´„Éâ„ÇíË°®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ

ÂêÑ„Éï„Ç£„Éº„É´„Éâ„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´ÂÆöÁæ©„Åï„Çå„Çã `type` „ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ

```ts
export type FieldType = 'string' | 'number' | 'boolean' | 'tag' | 'string[]' | 'number[]' | 'tags';
```

| type     | note                                   |
| -------- | -------------------------------------- |
| string   | ÂÖ®ÊñáÊ§úÁ¥¢„Çí„Çµ„Éù„Éº„Éà„Åô„Çã„ÉÜ„Ç≠„Çπ„ÉàÂûã       |
| number   | ÂÆåÂÖ®‰∏ÄËá¥Ê§úÁ¥¢„ÅÆ„Åø„Çµ„Éù„Éº„Éà„Åô„ÇãÊï∞ÂÄ§Âûã     |
| boolean  | ÂÆåÂÖ®‰∏ÄËá¥Ê§úÁ¥¢„ÅÆ„Åø„Çµ„Éù„Éº„Éà„Åô„ÇãÁúüÂÅΩÂÄ§Âûã   |
| tag      | ÂÆåÂÖ®‰∏ÄËá¥Ê§úÁ¥¢„ÅÆ„Åø„Çµ„Éù„Éº„Éà„Åô„Çã„ÉÜ„Ç≠„Çπ„ÉàÂûã |
| string[] | string Âûã„ÅÆÈÖçÂàó                        |
| number[] | number Âûã„ÅÆÈÖçÂàó                        |
| tags     | tag Âûã„ÅÆÈÖçÂàó                           |

ÂêÑ„Éï„Ç£„Éº„É´„Éâ„ÅØ `indexed` „Çí `true` „Å´„Åô„Çã„Å®Ê§úÁ¥¢ÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åô„ÄÇÂæì„Å£„Å¶„ÄÅ„Åì„ÅÆ‰æã„ÅÆ`SCHEMA` „Åß„ÅØ„ÄÅ"key" „Éï„Ç£„Éº„É´„Éâ„ÅÆÂÆåÂÖ®‰∏ÄËá¥Ê§úÁ¥¢„Åä„Çà„Å≥ "content" „Éï„Ç£„Éº„É´„Éâ„ÅÆÂÖ®ÊñáÊ§úÁ¥¢ (ÈÉ®ÂàÜ‰∏ÄËá¥Ê§úÁ¥¢) „ÇíË°å„ÅÜ‰∫ã„ÅåÂá∫Êù•„Çã‰∏ÄÊñπ„ÄÅ"updatedAt" „Éï„Ç£„Éº„É´„Éâ„ÅßÊ§úÁ¥¢„Åô„Çã„Åì„Å®„ÅØÂá∫Êù•„Åæ„Åõ„Çì„ÄÇ

### „Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆËøΩÂä†

„Åì„ÅÆÊÆµÈöé„Åß `collection` „Å´„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíËøΩÂä†„ÅóÂßã„ÇÅ„Çã„Åì„Å®„ÅåÂá∫Êù•„Åæ„Åô„ÄÇËøΩÂä†„Åô„Çã„Éâ„Ç≠„É•„É°„É≥„Éà„ÅØÂÆöÁæ©Ê∏à„Åø„ÅÆ„Çπ„Ç≠„Éº„Éû„Å´Ê≤ø„Å£„Å¶„ÅÑ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ‰øùÂ≠ò„Åô„Çã„Éá„Éº„Çø„ÅØ "values" „Éó„É≠„Éë„ÉÜ„Ç£„Å®„Åó„Å¶ÂÆöÁæ©„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇ

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const doc1: Document = collection.add({
    values: {
        key: 'doc_key_1',
        content: 'Any text üíØ‚ùóÔ∏è',
        updatedAt: Date.now(),
    },
});
const doc2: Document = collection.add({
    values: {
        key: 'doc_key_2',
        content: 'Text content üíØ‚ùóÔ∏è',
        updatedAt: Date.now(),
    },
});
/*
doc1 = {
    id: 1,
    values: ...,
};
doc2 = {
    id: 2,
    values: ...,
};
*/
```

„É©„Ç§„Éñ„É©„É™„Å´„Çà„Å£„Å¶ `id` „Éï„Ç£„Éº„É´„Éâ„ÅåËá™ÂãïÁöÑ„Å´Áô∫Ë°å„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„Å´Ê∞ó‰ªò„ÅÑ„Åü„Åß„Åó„Çá„ÅÜ„Åã„ÄÇ„Åì„ÅÆ `id` „ÅØÂêÑ„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆË≠òÂà•Â≠ê„Åß„Åô„ÄÇ„Åß„Åô„ÅÆ„Åß„ÄÅ„Åì„ÅÆ `id` „Çí‰ΩøÁî®„Åó„Å¶„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÂèñÂæó (`get`) „Åó„Åü„Çä„ÄÅÂâäÈô§ (`remove`) „Åó„Åü„Çä„Åô„Çã‰∫ã„ÅåÂá∫Êù•„Åæ„Åô„ÄÇ

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const doc1: Document = collection.get(1);
const removedDoc1: Document = collection.remove(1);
```

### „Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÊ§úÁ¥¢

„Åï„Å¶„Å§„ÅÑ„Å´„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÊ§úÁ¥¢„Åô„Çã„Åì„Å®„ÅåÂá∫Êù•„Çã„Çà„ÅÜ„Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const result1: Set<Document> = collection.find({ key: 'doc_key_1' });
const result2: Set<Document> = collection.find({ content: 'üíØ' });
```

„Åì„Åì„Åß„ÄÅSet „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ `result1` „ÅØ„ÄÅkey „Åå "doc_key_1" „Å´ÂÆåÂÖ®‰∏ÄËá¥„Åô„Çã ‰∏Ä„Å§„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇSet „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ `result2` „ÅØ„ÄÅcontent „Åå "üíØ" „Å´ÈÉ®ÂàÜ‰∏ÄËá¥„Åô„Çã‰∫å„Å§„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÊåÅ„Å°„Åæ„Åô„ÄÇ

Ê§úÁ¥¢ÁµêÊûú„Çí„ÇΩ„Éº„Éà„Åó„Åü„ÅÑÂ†¥Âêà„ÇÇ„ÄÅ„ÇÇ„Å°„Çç„ÇìÂèØËÉΩ„Åß„Åô„ÄÇ

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const result: Document[] = Array.from(collection.find({ content: 'üíØ' }));
const sortedResult: Document[] = result.sort((left, right) => left.updatedAt - right.updatedAt);
```

Ê§úÁ¥¢ÁµêÊûú„Åå `Set` „Åß„ÅÇ„Çã‰∫ã„Å´ÁïôÊÑè„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇÂæì„Å£„Å¶„ÄÅ„ÇΩ„Éº„Éà„Çí„Åô„ÇãÂ†¥Âêà„ÅØ `Array` „Å´Â§âÊèõ„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

### „Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÊõ¥Êñ∞

„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥„Å´‰øùÂ≠ò„Åó„Åü„Éâ„Ç≠„É•„É°„É≥„Éà„ÇíÊõ¥Êñ∞„Åô„ÇãÂ†¥Âêà„ÄÅ„Åæ„Åö„Åù„ÅÆ `id` „ÇíÂèñÂæó„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ„Åù„ÅÆÂæå„Å´„ÄÅ`update` „É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åó„Å¶„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆÊõ¥Êñ∞„Çí„Åó„Åæ„Åô„ÄÇ

```ts
import { Document } from '@otchy/sim-doc-db/dist/types';

const current: Document = Array.from(collection.find({ key: 'doc_key_1' }))[0];
const updated: Document = {
    id: current.id,
    values: {
        ...current.values,
        content: 'Updated!',
        updatedAt: Date.now(),
    },
};
collection.update(updated);
```

### „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Å®„Ç§„É≥„Éù„Éº„Éà

SimDoc DB Ëá™Ë∫´„ÅØ„Ç∑„É≥„Éó„É´„Å™„Ç§„É≥„É°„É¢„É™„Éá„Éº„Çø„Éô„Éº„Çπ„Å®„Åó„Å¶„Éá„Ç∂„Ç§„É≥„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅÊ∞∏Á∂öÊÄß„ÇíÊåÅ„Å°„Åæ„Åõ„Çì„ÄÇ„Åß„Åô„Åå„ÄÅ„Ç®„ÇØ„Çπ„Éù„Éº„Éà (`export`) „Å®„Ç§„É≥„Éù„Éº„Éà (`import`) „Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Éá„Éº„Çø„Éô„Éº„Çπ„ÇíÊ∞∏Á∂öÁöÑ„Å´‰øùÂ≠ò„Åô„Çã„Åì„Å®„ÇÇÂá∫Êù•„Åæ„Åô„ÄÇ

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Json } from '@otchy/sim-doc-db/dist/types';

const jsonData: Json = collection.export();
const textData = Json.stringify(jsonData);
// „Åì„Çå„Çí„Å©„Åì„Åã„Å´‰øùÂ≠ò„Åô„Çã

const copiedCollection = new Collection(SCHEMA);
copiedCollection.import(jsonData);
```

„ÉÄ„É≥„Éó„Åï„Çå„Åü„Éá„Éº„Çø„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÅØ `Json` „Åß„Åô„ÄÇÂæì„Å£„Å¶„ÄÅÊñáÂ≠óÂàóÂåñ (`stringify`) „Åó„Åü‰∏ä„Åß‰æã„Åà„Å∞„Éá„Ç£„Çπ„ÇØ‰∏ä„Å´‰øùÂ≠ò„Åô„Çã„Åì„Å®„ÅåÂá∫Êù•„Åæ„Åô„ÄÇ„Åù„Åó„Å¶„ÇÇ„Å°„Çç„Çì„Åù„ÅÆ„Éá„Éº„Çø„ÇíÂøÖË¶Å„Å´Âøú„Åò„Å¶„Ç§„É≥„Éù„Éº„Éà (`import`) „Åß„Åç„Åæ„Åô„ÄÇ

### Â§öÈöéÂ±§„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†

ÊúÄÂàù„Å´Ëø∞„Åπ„Åü„Çà„ÅÜ„Å´„ÄÅ„Åì„ÅÆ„É©„Ç§„Éñ„É©„É™„ÅØÂ§öÈöéÂ±§„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„ÇíÊâ±„ÅÜ„Åì„Å®„ÅØÂá∫Êù•„Åæ„Åõ„Çì„ÄÇ„Åß„Åô„Åå„Å©„ÅÜ„Åó„Å¶„ÇÇ„Åù„ÅÜ„ÅÑ„Å£„Åü„Éá„Éº„ÇøÊßãÈÄ†„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÄÅ‰ª•‰∏ã„ÅÆÊñπÊ≥ï„Åß„Ç®„Éü„É•„É¨„Éº„Éà„Åô„Çã„Åì„Å®„ÅåÂá∫Êù•„Åæ„Åô„ÄÇ

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Field } from '@otchy/sim-doc-db/dist/types';

const SCHEMA: Field[] = [
    {
        name: 'groupId',
        type: 'number',
        indexed: true,
    },
    {
        name: 'name',
        type: 'string',
        indexed: true,
    },
    {
        name: 'members',
        type: 'string[]',
        indexed: false,
    },
];

type Member = {
    memberId: number;
    name: string;
};

type Group = {
    groupId: number;
    name: string;
    members: Member[];
};

const collection = new Collection(SCHEMA);

const addGroup = ({ groupId, name, members }: Group) => {
    collection.add({
        values: {
            groupId,
            name,
            members: members.map((member: Member) => JSON.stringify(member)),
        },
    });
};

const getGroup = (groupId: number): Group => {
    const doc = Array.from(collection.find({ groupId }))[0];
    return {
        groupId: doc.values.groupId,
        name: doc.values.name,
        members: doc.values.members.map((member) => JSON.parse(member) as Member),
    };
};
```

„Åì„ÅÆ„Éë„Çø„Éº„É≥„ÅÆÊ¨†ÁÇπ„ÅØ„ÄÅMember „ÅÆ name „ÅßÊ§úÁ¥¢„Åô„Çã„Åì„Å®„ÅåÂá∫Êù•„Å™„ÅÑÁÇπ„Åß„Åô„ÄÇ`` collection.find({ members: `"name":"${name}"` }) `` „ÅÆ„Çà„ÅÜ„Å´ JSON ÊñáÂ≠óÂàó„ÇíÊ§úÁ¥¢„Åô„Çã„Åì„Å®„ÅØÂèØËÉΩ„Åß„Åô„Åå„ÄÅ„Åã„Å™„Çä„ÅÆ„Éè„ÉÉ„ÇØ„Åß„Åô„Åó„ÅäÂãß„ÇÅÂá∫Êù•„Åæ„Åõ„Çì„ÄÇ

Âà•„ÅÆÊ°à„Å®„Åó„Å¶„ÄÅ‰∏ãË®ò„ÅÆ„Çà„ÅÜ„Å™ÊñπÊ≥ï„ÇÇ„ÅÇ„Çä„Åæ„Åô„ÄÇ

```ts
import { Collection } from '@otchy/sim-doc-db';
import { Field } from '@otchy/sim-doc-db/dist/types';

const GROUP_SCHEMA: Field[] = [
    {
        name: 'groupId',
        type: 'number',
        indexed: true,
    },
    {
        name: 'name',
        type: 'string',
        indexed: true,
    },
    {
        name: 'memberIds',
        type: 'number[]',
        indexed: true,
    },
];

const MEMBER_SCHEMA: Field[] = [
    {
        name: 'memberId',
        type: 'number',
        indexed: true,
    },
    {
        name: 'groupId',
        type: 'number',
        indexed: false,
    },
    {
        name: 'name',
        type: 'string',
        indexed: true,
    },
];

type Member = {
    memberId: number;
    groupId: number;
    name: string;
};

type Group = {
    groupId: number;
    members: Member[];
};

const groupCollection = new Collection(GROUP_SCHEMA);
const memberCollection = new Collection(MEMBER_SCHEMA);

const addGroup = ({ groupId, name, members }: Group) => {
    groupCollection.add({
        values: {
            groupId,
            name,
            memberIds: members.map((member) => member.memberId),
        },
    });
    members.forEach(({ memberId, name }) => {
        memberCollection.add({
            values: {
                memberId,
                groupId,
                name,
            },
        });
    });
};

const getGroup = (groupId: number): Group => {
    const groupDoc = Array.from(groupCollection.find({ groupId }))[0];
    const members = groupDoc.values.memberIds.map((memberId) => {
        return Array.from(memberCollection.find({ memberId }))[0].values as Member;
    });
    return {
        groupId: groupDoc.values.groupId,
        name: groupDoc.values.name,
        members,
    };
};

const findByMemberName = (name: string): Group => {
    const memberDoc = Array.from(memberCollection.find({ name }))[0];
    const groupId = memberDoc.values.groupId;
    return getGroup(groupId);
};
```

„Åì„ÅÆ„Éë„Çø„Éº„É≥„ÅØ RDB „ÅßÂ§öÈöéÂ±§„ÅÆ„Éá„Éº„ÇøÊßãÈÄ†„ÇíÊâ±„ÅÜÊñπÊ≥ï„Å®‰ºº„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åü„Å†„ÄÅSimDoc DB „Åå SQL „Çí„Çµ„Éù„Éº„Éà„Åô„Çã„Çè„Åë„Åß„ÅØÁÑ°„ÅÑ„ÅÆ„Åß„ÄÅ"JOIN" Áõ∏ÂΩì„ÅÆ„Éá„Éº„ÇøÊìç‰Ωú„ÇíËá™ÂàÜ„ÅßÂÆüË£Ö„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

## Development

### Initial setup

```
$ git config --local core.hooksPath .githooks
```
